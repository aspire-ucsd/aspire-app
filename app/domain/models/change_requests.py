from typing import Optional, Literal, List, Union
import enum
import json
from datetime import datetime, UTC
from sqlmodel import Field, SQLModel, Column, CheckConstraint, Enum, select, TIMESTAMP
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import Mapped, mapped_column
from pydantic import BaseModel, field_validator, Field as PydanticField

from sqlalchemy import event
from sqlalchemy.orm import Mapper
from sqlalchemy.ext.mutable import MutableList
from sqlalchemy.types import TypeDecorator 


class ValidationStatusEnum(str, enum.Enum):
    draft="draft"
    pending="pending"
    approved="approved"
    rejected="rejected"


class ModificationTypeEnum(str, enum.Enum):
    create="create"
    update="update"
    delete="delete"


class EntityTypeEnum(str, enum.Enum):
    concept="concept" # For validating changes to the Concept table.
    concept_to_concept="concept_to_concept" # For validating changes to the ConceptToConcept table.
    question="question" # For validating changes to the Question table.
    answer="answer" # For validating changes to the Answer table.

class VoteTypeEnum(str, enum.Enum):
    veto="veto"
    simple_majority="simple_majority"

class CommentTypeEnum(str, enum.Enum):
    text="text"
    proposal="proposal"
    update="update"

class Comment(BaseModel):
    type: Literal["text", "proposal", "update", "reject_vote", "approve_vote"]
    content: str
    submitted_by: Optional[int] = None
    submitted_at: Union[datetime, str] = PydanticField(default_factory=lambda:datetime.now(UTC))


class CustomJSONEncoder(json.JSONEncoder):
    """Custom JSON encoder for handling the Comment Pydantic Model."""
    def default(self, obj):

        if isinstance(obj, Comment):
            obj.submitted_at = str(obj.submitted_at)
            return obj.model_dump() 
        
        if isinstance(obj, datetime):
            return obj.strftime('%Y-%m-%d %H:%M:%S %Z')
        
        return super().default(obj)


class CustomJSON(TypeDecorator):
    """Custom JSON type for encoding/decoding with JSONB."""
    impl = MutableList.as_mutable(JSONB)
    cache_ok = True

    def process_bind_param(self, value, dialect):
        """Encode Python object to JSON before saving."""
        if value is None:
            return value
        return json.dumps(value, cls=CustomJSONEncoder)


    def process_result_value(self, value, dialect):
        """Decode JSON back into Python object after retrieval."""
        
        if isinstance(value, list):
            return value
        return [Comment(**item) for item in json.loads(value)]


class CustomDatetime(TypeDecorator):
    impl = MutableList.as_mutable(TIMESTAMP)
    cache_ok = True
    
    def process_result_value(self, value, dialect):
        if isinstance(value, datetime):
            return value.strftime('%Y-%m-%d %H:%M:%S %Z') + "UTC"
        return value

class ChangeRequestBase(SQLModel):
    entity_id: Optional[str] = None # The source id of an existing table entry if validation would require a comparison.
    is_from_llm: bool = False # is this change generated by the llm?
    post_approval_procedure: dict = Field(sa_type=JSONB, default_factory=dict) # How the object will be integrated with the domain model upon approval, ex. new concept added and also joined to a module
    entity_data: dict = Field(sa_type=JSONB, default_factory=dict)
    entity_type: EntityTypeEnum = Field(max_length=50, sa_column=Column(Enum(EntityTypeEnum)))
    modification_type: Optional[ModificationTypeEnum] = Field(max_length=50, default=None, sa_column=Column(Enum(ModificationTypeEnum), nullable=True))
    validation_status: ValidationStatusEnum = Field(default="pending", sa_column=Column(Enum(ValidationStatusEnum)))
    comments: List[Comment] = Field(
        sa_column=Column(CustomJSON),
        default_factory=list
    )



class ChangeRequestExtended(ChangeRequestBase):
    submitted_by: int = Field(foreign_key="client.id", nullable=True, ondelete="SET NULL")
    submitted_at: Union[str, datetime] = Field(sa_column=Column(CustomDatetime), default_factory=lambda: datetime.now(UTC))

    reviewers: List[int] = Field(sa_type=JSONB, default_factory=list)
    vote_type: Optional[VoteTypeEnum] = Field(default=None, max_length=100, sa_column=Column(Enum(VoteTypeEnum), nullable=True))
    votes: List[str] = Field(sa_type=JSONB, default_factory=list)
    closes_at: Optional[Union[str, datetime]] = Field(sa_column=Column(CustomDatetime, nullable=True), default=None)
    committed_at: Optional[Union[str, datetime]] = Field(sa_column=Column(CustomDatetime, nullable=True), default=None)



class ChangeRequest(ChangeRequestExtended, table=True):
    #TODO: Update documentation to reflect changed made during development
    """
    Used for creating Validation Requests on data shared by courses, this includes Concepts, ConceptToConcept junctions, and items stored in the shared resource bank.
    Data falling under this catagory must be validated by SMEs prior to being promoted to the system, 
    who is allowed to review these changes depends upon the entity type, action requested in the validation type, and the source of the request:

    ==========================
    Who can review the request?
    ==========================
    Based on the provided `entity_type`, `validation_type`, and `source`, review access is assigned as follows:

    **Entity: 'concept'**
        - Modification: 'create'
            - Source: 'Human' → Reviewers: SMEs in the concepts subject
                - Vote: None
            - Source: 'LLM' → Reviewers: SMEs in the concepts subject
                - Vote: None
        - Modification: 'update'
            - Source: 'Human' → Reviewers: SMEs using the concept, excluding the submitter
                - Vote: Time-Restricted Simple Majority
            - Source: 'LLM' → Reviewers: SMEs using the concept
                - Vote: Time-Restricted Simple Majority
        - Modification: 'delete'
            - Source: 'Human' → Reviewers: SMEs using the concept, excluding the submitter
                - Vote: Time-Restricted Veto
            - Source: 'LLM' → Reviewers: SMEs using the concept, excluding the submitter
                - Vote: Time-Restricted Veto

    **Entity: 'concept_to_concept'**
        - Modification: 'create'
            - Source: 'Human' → Reviewers: SMEs using both concepts in the same course
                - Vote: Time-Restricted Simple Majority
            - Source: 'LLM' → Reviewers: SMEs using both concepts in the same course
                - Vote: Time-Restricted Simple Majority
        - Modification: 'update'
            - Not Applicable
        - Modification: 'delete'
            - Source: 'Human' → Reviewers: SMEs using both concepts in the same course, excluding the submitter
                - Vote: Time-Restricted Simple Majority
            - Source: 'LLM' → Reviewers: SMEs using both concepts in the same course
                - Vote: Time-Restricted Simple Majority

    **Entity: 'question'**
        - Modification: 'create'
            - Source: 'Human' → Reviewers: SMEs using the concept attached to the question
                - Vote: Time-Restricted Simple Majority
            - Source: 'LLM' → Reviewers: SMEs using the concept attached to the question
                - Vote: Time-Restricted Simple Majority
        - Modification: 'update'
            - Source: 'Human' → Reviewers: SMEs using the concept attached to the question, excluding the submitter
                - Vote: Time-Restricted Simple Majority
            - Source: 'LLM' → Reviewers: SMEs using the concept attached to the question
                - Vote: Time-Restricted Simple Majority
        - Modification: 'delete'
            - Source: 'Human' → Reviewers: SMEs using the concept attached to the question, excluding the submitter
                - Vote: Time-Restricted Veto
            - Source: 'LLM' → Reviewers: SMEs using the concept attached to the question
                - Vote: Time-Restricted Veto

    **Entity: 'answer'**
        - Modification: 'create'
            - Source: 'Human' → Reviewers: SMEs using the concept attached to the question
                - Vote: Time-Restricted Simple Majority
            - Source: 'LLM' → Reviewers: SMEs using the concept attached to the question
                - Vote: Time-Restricted Simple Majority
        - Modification: 'update'
            - Source: 'Human' → Reviewers: SMEs using the concept attached to the question, excluding the submitter
                - Vote: Time-Restricted Simple Majority
            - Source: 'LLM' → Reviewers: SMEs using the concept attached to the question
                - Vote: Time-Restricted Simple Majority
        - Modification: 'delete'
            - Not Applicable

    ============
    Voting Types
    ============

    There are two types of polls conducted for certain changes:

    1. Simple Majority - The result with the most votes wins, ties are rejected.
    2. Veto - Must not be rejected by anyone

    Assigned reviewers may only vote once per request and voting is anonymous.

    Our system will automatically close polls twice per weekday, once at 12:00pm PST and once at 5:00pm PST.
    The end of a poll will always default to one of the next two windows. 
    For simple majority whichever is shortest and also greater than or equal to 2 hours. 
    For veto it will default to whichever is greatest.

    If the poll is a simple majority, after the first three votes, the first vote per processing period that would result in a tie move the poll duration to the next processing window.
    Ex. 
    A request is made at 11:00am on Monday, the poll is set to conclude at 5:00pm on Monday, 4 votes are cast before 5:00pm that results in a tie, 
    the poll is now set to conclude at 12:00pm on Tuesday, 10 more votes are cast before 5:00pm on Monday and the poll is still tied,
    the poll still concludes at 12:00pm on Tuesday, 2 more votes come in Tuesday morning and its still a tie, the poll is now set to conclude at 5:00pm Tuesday,
    5 more votes come in before 5:00pm and the tie is broken, the poll concludes at 5:00pm with a winner and the request is processed.

    For veto style polls, the first 'rejected' vote closes the poll and the request is automatically rejected.

    If no vote is requred, the first approval or rejection is accepted
    """
    __tablename__ = "change_request"

    id: Optional[int] = Field(default=None, primary_key=True)
        # Custom property to handle Comment serialization/deserialization



def append_to_lists(mapper: Mapper, connection, target):
    """
    Event listener to append comments and votes on update instead of overwriting.
    """

    if target.comments:
        existing_comments_query = select(ChangeRequest.comments).where(ChangeRequest.id == target.id)
        existing_comments = connection.execute(existing_comments_query).scalar()
        
        if not isinstance(existing_comments, list):
            existing_comments = []

        if target.comments != existing_comments:
            target.comments = existing_comments + target.comments
        

    if target.votes:
        existing_votes_query = select(ChangeRequest.votes).where(ChangeRequest.id == target.id)
        existing_votes = connection.execute(existing_votes_query).scalar()
        
        if not isinstance(existing_votes, list):
            existing_votes = []
        
        target.votes = existing_votes + target.votes


    if target.reviewers and target.votes:

        existing_reviewers_query = select(ChangeRequest.reviewers).where(ChangeRequest.id == target.id)
        existing_reviewers = connection.execute(existing_reviewers_query).scalar()
        
        if not isinstance(existing_reviewers, list):
            existing_reviewers = []
        # Removes reviewers if both reviewers and votes are provided, indicating a cast vote
        target.reviewers = [item for item in existing_reviewers if item not in target.reviewers]
        

    if target.reviewers is None:
        existing_reviewers_query = select(ChangeRequest.reviewers).where(ChangeRequest.id == target.id)
        existing_reviewers = connection.execute(existing_reviewers_query).scalar()
        
        if not isinstance(existing_reviewers, list):
            existing_reviewers = []

        target.reviewers = existing_reviewers


    if target.votes is None:
        existing_votes_query = select(ChangeRequest.votes).where(ChangeRequest.id == target.id)
        existing_votes = connection.execute(existing_votes_query).scalar()

        target.votes = existing_votes

event.listen(ChangeRequest, 'before_update', append_to_lists)


class ChangeRequestRead(ChangeRequestExtended):
    id: Optional[int]

class ChangeRequestCreateClient(ChangeRequestBase):
    pass

class ChangeRequestCreate(ChangeRequestExtended):
    pass

class ChangeRequestUpdate(BaseModel):
    id: int
    reviewed_by: Optional[int] = None
    comments: Optional[List[Comment]] = None
    reviewers: Optional[List[int]] = None
    votes: Optional[List[str]] = None
    validation_status: Optional[Literal["pending", "approved", "rejected", "draft"]] = None
    closes_at: Optional[datetime] = None
    committed_at: Optional[datetime] = None
    entity_data: Optional[dict] = None